# **Краткое руководство по работе с репозиториями локальной системы Git и сервисом удаленных репозитариев GitHub.**
Все ниже изложенное приводится для операционной системы Lunux.
Перечень используемого ПО: Терминал среды **xfce**, Графический файловый менеджер *Thunar*, Консольный файловый менеджер *Far2l* либо *Midnight Commander*, Интернет браузер **Яндекс**.
***

## **1. Установка Git**

Её можно производить либо с помощью специальных графических программ управления пакетами (в моё случае Synuptic), либо с помощью комманд bash в окне терминала что мы и будем использовать.
Поехали...
```bash
sudo apt-get install git
```
установили. Всё просто. если не возникло ошибок.

## **2. Первоначальная настройка**

Проверим как установился наш Git

```bash
git version
```
Теперь внесём пару глобальных параметров. Глобальные - значит единые для всех репозиториев(проектов).

```bash
git config --global user.name "VNPokrovskj"
git config --global user.email pvn1054@mail.ru
```
Внесил учётное имя пользователя Git и его электронную почту.
Все глобальные данные находятся в домашней папке в файле ~/.gitconfig
Посмотреть их можно командами:

```bash
cat ~/.gitconfig
```
либо

```bash
git config --list
```
## **3. Создаем свой проект(локальный репозиторий).**

Для этого необходимо сделать новую директорию в домашнем каталоге. Пусть будет MyTestProject.
Набираем команду:

```bash
md MyTestProject
```
Получили новую папку в домашней директории - ~/MyTestProject. Переходим во вновь созданный каталог.

```bash
cd MyTestProject
```
Теперь создем два пустых тестовых файл readme.txt, todo.txt.

```bash
touch readme.txt
```
а второй файл сделаем по другому, он будет не пустой - сразу добавим строку. Поехали...

```bash
echo '1.Мое первое запланированное дело'>todo.txt
```
Вот так. 
Создаем собственно проект.

```bash
git init
```
Если посмотреть содержимое нашей папки, то мы увидим что результатом работаы последней команды стала новая скрытая папка с кучей всякого содержимого - .git. Это и есть вся служебная структура - база данных нашего вновь созданного проекта. Здесь будут отражаться все изменения производимые с файлами в папке проекта - readme.txt, todo.txt. 
Теперь нужно два этих файла добавить в проект.
Либо так:

```bash
git add --all
```
добавили сразу все файлы из нашей папки.

Второй способ, каждый файл отдельной коммандой (чуть подлинней особенно если нужно добавить не один файл, а большую кучу файлов, в нашем случае - два):

```bash
git add readme.txt
git add todo.txt
```
Мы внесил изменения в проект, но они еще не закреплены, не записаны.
Записываем его текущее состояние.

```bash
git commit -n 'Создали новый проект'
```
Теперь записана начальная точка проекта.
На любом этапе от создания(init-а) этого проекта мы можем поглядеть его статус:

```bash
git status
```
## **4. Внесение изменение путем редактирования файлов проекта.**

Отредактируем файлы проекта. Добавим строки в файл readme.txt и todo.txt. Используем для этого любой текстовый редактор. 
Для этого открываем эти файлы в файловом менеджере графическом или консольном. Используем либо Thunar(графический ФМ), либо MC или Far2l(консольные ФМ). Редактируем и записываем.
Теперь опять добавляем изменения в проект:

```bash
git add --all
```
так или вторым способом.
Записываем изменения в проект.

```bash
git commit -n 'Изменили файл readme.txt. Добавили новое дело в файл todo.txt'
```

## **5. Создание и работа с удаленными репозиторимями на GitHub.**

Теперь необходимо создать удаленный репозиторий который мы будем синхронизировать с нашим локальным git проекторм. Для этого будем использовать сайт Microsoft Corporation с соответствующим названием - GitHub. Открываем интернет браузер (в нашем случае Яндекс браузер).  
Идем по ссылке:[GitHub](https://github.com)  
Создаем личный кабинет и одноимённый с нашим локальным удалённый проект. Подробное описание как всё это делать можно посмотреть на самом сайте в разделе документации и даже на русском языке.[Ссылка на раздел документации](https://docs.github.com/ru/get-started/using-git/about-git).  
Поскольку политика этого сайта не предусматривает работу с удаленным репозиторием по логину и паролю (которые будут использованы при создании личного кабинета), нужно будет использовать сертификат ключа для доступа с использованием ssh. Изготовим этот ключ. Оболочка ssh у нас установлена, так что поехали...
* Сначала мастерим ключ

   ```bash
   ssh-keygen -t ed25519 -C "my.test.e-mail@yandex.ru"
   ```
   в этой команде мы указали алгоритм шифрования - ed25519 и адрес электронной почты - "my.test.e-mail@yandex.ru"(меняем на свой). После этого в домашней директории в содается скрытая папка (если ее не было) 
   ~/.ssh и в ней генерируются два файла ключей ssh - приватный и публичный.  
   - id_ed25519 (файл без расширения - приватный ключ)  
   - id_ed25519.pub (файл с расширением pub - публичный ключ, его мы и будем использовать)
  
   При генерации запрашивается логин и пароль. Логин вводим. Можно такой же как учетное имя на GitHub. Пароль по хорошему тоже надо ввести, это будет правильно. Можно и пустым оставить. Особенно для 
   тестового использования.
* Привязка ключа к личному кабинету на GitHub.

   Открываем публичный ключ любым редактором и выделяем и копируем всё содержимое. Идем на GitHub. В личном кабинете щелкаем левой кнопкой на пиктограмме профиля пользователя в правом верхнем углу страницы. Появляется меню. Выбираем пункт **Settings**. Откроется страничка установки параметров профиля. Слева по порядку разделы параметров. Нам нужно выбрать **SSH and GPG keys**. В открывшейся вкладке выбираем кнопку **New SSH key**. В поле **Title** пишем название ключа. Например, *Personal key*. В поле **Key type** должно быть *Authentication Key*. В поле **Key** вставляем из буфера обмена содержимое нашего публичного ключа. Сохраняем введённые данные кнопкой **Add SSH key**. Вроде всё.
* Проверяем действие ключа.

   ```bash
   ssh -T git@github.com
   ```
   При первом подключении могут возникнуть проблемы. Дальше...

* Прилепляем удалённый репозиторий к локальному.
  
   ```bash
   git remote add origin git@github.com:TestGitHubUser/MyTestProject.git
   ## Проверяем соединение
   git remote -v
   ```
   При возникновении ошибок на этом этапе также поможет комманда:

   ```bash
   git remote set-url origin git@github.com:TestGitHubUser/MyTestProject.git
   ```
* Пробуем синхронизацию - отправку данных локального проекта.
  
   ```bash
   git push -u origin main
   ```
* Для получения данных из удалённого репозитория.
  
   ```bash
   git pull origin main
   ```
Вот собственно и всё. Локальный и удаленный проекты Git теперь связаны. Можно пользоваться.

## **6. Хэш-идентификатор**

Хеш — это основной идентификатор снимка проекта (или коммита - commit). Git хранит таблицу соответствий хеш - информация о снимке.
Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. 
Хэши можно будет передавать в качестве параметра разным Git-командам, чтобы указать, с каким снимком нужно произвести то или иное действие. 
Все хеши и таблицу хеш - информация о снимке Git сохраняет в служебные файлы. Они находятся в скрытой папке *.git* в репозитории проекта.

Обычно хеш — это короткая (40 символов в случае SHA-1) строка, которая состоит из цифр 0—9 и латинских букв A—F (неважно, заглавных или строчных). Она обладает следующими важными свойствами:

* если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;
* если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).

Вот пример вывод результата команды _git log_:

  ```bash
commit ecc1ddd1ca7d97c09f3e0d123c4bf7046832602f (HEAD -> main, origin/main, origin/HEAD)
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Fri Nov 24 16:45:18 2023 +0300

    Update README.md

commit ffb372d7eae4d5bdc28e139bf9bbf646c5ca424a
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Fri Nov 24 16:20:10 2023 +0300

    Update README.md

commit 89056ed7ebec41de3af28165ea0f9c7383e215cc
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Thu Nov 23 10:30:41 2023 +0300

    Update README.md

commit 1a891c4c6a35a9901de7d534ccdf89f59d6be7b0
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Thu Nov 23 09:35:43 2023 +0300

    Update README.md

commit 9c3dbe43321c76bfbdc6b242cfdd91bba7777674
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Wed Nov 22 16:22:39 2023 +0300

    Update README.md

commit 5b1e9e61dee8357e7c621be21bb3a8595b9b854e
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Wed Nov 22 13:45:41 2023 +0300

    Update README.md
  ```
Мы видим несколько однотипных фрагментов информации. Это информация о всех сохраненных состояниях(снимках, коммитах - как больше нравится; здесь я употребляю слово *состояние*, но в программистском, склонном к англицызмам обществе принято использовать слово из соответствующей команды **git** - *commit* по русски - *коммит*)  проекта.

Рабор по строкам самого вергнего фрагмента.
  ```bash
commit ecc1ddd1ca7d97c09f3e0d123c4bf7046832602f (HEAD -> main, origin/main, origin/HEAD)
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Fri Nov 24 16:45:18 2023 +0300

    Update README.md
  ```
* Хэш - ecc1ddd1ca7d97c09f3e0d123c4bf7046832602f.
* Указатель на то что это самый последний снимок состояния проекта - *(HEAD -> main, origin/main, origin/HEAD)*. Если необходимо будет передать какой либо хэш любому участнику проекта, то для самого свежего можно просто указать слово - HEAD, без указания хэша.
* Автор снимака и его данные - *Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>*.
* Дата снимка - *Date:   Fri Nov 24 16:45:18 2023 +0300*.
* Сообщение снимка - *Update README.md*.

Хеширование (от англ. hash, «рубить», «крошить», «мешанина») — это способ преобразовать набор данных и получить их «отпечаток» (англ. fingerprint). Информация о снимке — это набор данных: когда был сделан снимок, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), снимок.

## **7. Сокращенный лог.**

Получить сокращённый лог можно с помощью команды *git log* с флагом --oneline (англ. «одной строкой»). В терминале появятся только первые несколько символов хеша каждого снимка и их комментарии.

  ```bash
ecc1ddd (HEAD -> main, origin/main, origin/HEAD) Update README.md
ffb372d Update README.md
89056ed Update README.md
1a891c4 Update README.md
9c3dbe4 Update README.md
5b1e9e6 Update README.md
d071af7 Первый полный вариант текста README.md файла проекта.
f7a9340 Update task.txt
1ba4aaa Add new file task.txt
1272a8a Initial commit
  ```

Сокращённый лог полезен, если в репозитории уже много снимков — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию.
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда *git log --oneline* автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком снимке идёт речь.

## **8. Файл HEAD**
Выше уже было описание указателя HEAD. Теперь подробнее.
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки *.git*. Он указывает на снимок, который сделан последним (то есть на самый новый).
В этом можно убедиться с помощью терминала. Перейдите в папку *.git* командой *cd*. Посмотрите содержимое файла HEAD командой *cat*.

  ```bash
$ cd .git/
$ ls # посмотрели, какие есть файлы
branches  config  description  FETCH_HEAD  HEAD  hooks  index  info  logs  objects  ORIG_HEAD  packed-refs  refs

$ cat HEAD # команда cat показывает содержимое файла
ref: refs/heads/main # в файле вот такая ссылка 
  ```

Внутри HEAD — ссылка на служебный файл: *refs/heads/main* (или *refs/heads/master* в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего снимка.

  ```bash
$ cat refs/heads/main # взяли ссылку из файла HEAD
# внутри хеш
ecc1ddd1ca7d97c09f3e0d123c4bf7046832602f

$ git log 
# сверяем с хешем последнего коммита
commit ecc1ddd1ca7d97c09f3e0d123c4bf7046832602f
Author: VikNikPokrovskj <151533338+VikNikPokrovskj@users.noreply.github.com>
Date:   Fri Nov 24 16:45:18 2023 +0300

    Update README.md

... # другие снимки 
  ```

Когда вы делаете новый снимок проекта - коммит, Git обновляет *refs/heads/master* — записывает в него хеш последнего снимка. Получается, что HEAD тоже обновляется, так как ссылается на *refs/heads/master*.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш снимка. Если нужно передать последний снимок, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.
